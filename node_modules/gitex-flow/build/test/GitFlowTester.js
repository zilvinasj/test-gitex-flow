"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.TestBranch = exports.GitFlowTester = void 0;
const os_1 = require("os");
const chai_1 = require("chai");
const TestGitRepository_1 = require("./TestGitRepository");
const path_1 = require("path");
const fs_extra_1 = require("fs-extra");
/**
 * Tester for some standard git flow tests.
 */
class GitFlowTester {
    /**
     * Initializes a new instance of this class.
     *
     * @param gitFlow - Git flow implementation to be tested.
     * @param testRepoPath - Path the test repo is saved to.
     */
    constructor(gitFlow, testRepoPath) {
        this.gitFlow = gitFlow;
        this.repo = new TestGitRepository_1.TestGitRepository({
            projectPath: testRepoPath,
        });
    }
    /**
     * Init the git flow tester.
     */
    init() {
        return __awaiter(this, void 0, void 0, function* () {
            yield this.dispose();
            yield GitFlowTester.ensureGitFlowRepo(this.gitFlow, this.repo);
        });
    }
    /**
     * Disposes the git flow tester.
     */
    dispose() {
        return __awaiter(this, void 0, void 0, function* () {
            yield this.repo.remove();
        });
    }
    /**
     * Clears the cache.
     */
    static clearCache() {
        return __awaiter(this, void 0, void 0, function* () {
            yield fs_extra_1.emptyDir(GitFlowTester.CachedGitFlowRepo);
            yield fs_extra_1.rmdir(GitFlowTester.CachedGitFlowRepo);
        });
    }
    /**
     * Asserts the version.
     */
    assertVersion() {
        return __awaiter(this, void 0, void 0, function* () {
            const version = yield this.gitFlow.version();
            chai_1.assert.match(version, /^[0-9]+.[0-9]+.[0-9]+.*/);
        });
    }
    /**
     * Asserts the initialization of the test git flow.
     *
     * @param config - The git flow configuration.
     * @param force - Flag to force the initialization.
     */
    assertInit(config, force) {
        var _a, _b, _c, _d, _e, _f, _g;
        return __awaiter(this, void 0, void 0, function* () {
            yield this.repo.ensure();
            yield this.gitFlow.init(config, force);
            const activeConfig = yield this.gitFlow.config.get();
            chai_1.assert.equal(activeConfig.masterBranch, (_a = config === null || config === void 0 ? void 0 : config.masterBranch) !== null && _a !== void 0 ? _a : 'master');
            chai_1.assert.equal(activeConfig.developBranch, (_b = config === null || config === void 0 ? void 0 : config.developBranch) !== null && _b !== void 0 ? _b : 'develop');
            chai_1.assert.equal(activeConfig.featureBranchPrefix, (_c = config === null || config === void 0 ? void 0 : config.featureBranchPrefix) !== null && _c !== void 0 ? _c : 'feature/');
            chai_1.assert.equal(activeConfig.bugfixBranchPrefix, (_d = config === null || config === void 0 ? void 0 : config.bugfixBranchPrefix) !== null && _d !== void 0 ? _d : 'bugfix/');
            chai_1.assert.equal(activeConfig.releaseBranchPrefix, (_e = config === null || config === void 0 ? void 0 : config.releaseBranchPrefix) !== null && _e !== void 0 ? _e : 'release/');
            chai_1.assert.equal(activeConfig.hotfixBranchPrefix, (_f = config === null || config === void 0 ? void 0 : config.hotfixBranchPrefix) !== null && _f !== void 0 ? _f : 'hotfix/');
            chai_1.assert.equal(activeConfig.supportBranchPrefix, (_g = config === null || config === void 0 ? void 0 : config.supportBranchPrefix) !== null && _g !== void 0 ? _g : 'support/');
            chai_1.assert.equal(activeConfig.versionTagPrefix, config === null || config === void 0 ? void 0 : config.versionTagPrefix);
        });
    }
    /**
     * Checks out the development branch.
     */
    checkoutDevelopBranch() {
        return __awaiter(this, void 0, void 0, function* () {
            yield this.checkoutBranch('develop');
        });
    }
    /**
     * Checks out a branch.
     *
     * @param branchName - The branch name to be checked out.
     */
    checkoutBranch(branchName) {
        return __awaiter(this, void 0, void 0, function* () {
            yield this.repo.checkout(branchName);
        });
    }
    /**
     * Select the given git flow branch.
     *
     * @param type - The git flow branch type to be selected.
     *
     * @returns The selected git flow branch.
     */
    selectBranch(type) {
        switch (type) {
            case 'bugfix':
                return new TestBranch(this.gitFlow.bugfix, this.repo);
            case 'feature':
                return new TestBranch(this.gitFlow.feature, this.repo);
            case 'hotfix':
                return new TestBranch(this.gitFlow.hotfix, this.repo);
            case 'release':
                return new TestBranch(this.gitFlow.release, this.repo);
            case 'support':
                return new TestBranch(this.gitFlow.support, this.repo);
            default:
                throw new Error(`Type "${type}" is not supported.`);
        }
    }
    static ensureGitFlowRepo(gitFlow, repo) {
        return __awaiter(this, void 0, void 0, function* () {
            const cachePath = GitFlowTester.CachedGitFlowRepo;
            if (yield fs_extra_1.pathExists(cachePath)) {
                yield fs_extra_1.copy(cachePath, repo.getRepoPath());
            }
            else {
                yield repo.commitTestFile('package.json', 'chore(project): Added package.json');
                yield gitFlow.init();
                yield fs_extra_1.ensureDir(cachePath);
                yield fs_extra_1.copy(repo.getRepoPath(), cachePath);
            }
        });
    }
}
exports.GitFlowTester = GitFlowTester;
GitFlowTester.CachedGitFlowRepo = path_1.join(os_1.tmpdir(), 'GitFlowRepoTemplate');
/**
 * A GitFlowBranch with some extended functionality for easier unit tests.
 */
class TestBranch {
    /**
     * Initializes a new instance of this class.
     *
     * @param branch - Branch to be wrapped.
     * @param repo - The test repo.
     */
    constructor(branch, repo) {
        this.branch = branch;
        this.repo = repo;
        this.type = branch.type;
        this.defaultBase = branch.defaultBase;
    }
    /**
     * Gets the test git flow branch configuration.
     *
     * @returns The git flow branch configuration.
     */
    getConfig() {
        return this.branch.getConfig();
    }
    /**
     * Retrieves all test  branches from the current type.
     *
     * @returns All open branches from the current type.
     */
    list() {
        return this.branch.list();
    }
    /**
     * Starts the current test git flow branch.
     *
     * @param name - The name of the git flow branch.
     * @param base - The base of the git flow branch.
     *
     * @returns The name with its prefix.
     */
    start(name, base) {
        return __awaiter(this, void 0, void 0, function* () {
            this.branchName = yield this.branch.start(name, base);
            return this.branchName;
        });
    }
    /**
     * Finishes the current test git flow branch.
     *
     * @param name - The name of the git flow branch.
     * @param msg - The message to finish the test git flow branch.
     */
    finish(name, msg) {
        return __awaiter(this, void 0, void 0, function* () {
            yield this.branch.finish(name, msg);
        });
    }
    /**
     * Generates the test git flow branch name.
     *
     * @param name - The name of the test git flow branch.
     *
     * @returns The test git flow branch name.
     */
    generateBranchName(name) {
        return __awaiter(this, void 0, void 0, function* () {
            return name;
        });
    }
    /**
     * Commits a given file to the test repository.
     *
     * @param fileName - The file name to be commited.
     * @param msg - The commit message.
     */
    commit(fileName, msg) {
        return __awaiter(this, void 0, void 0, function* () {
            if (!this.branchName) {
                throw new Error('Branch was not started.');
            }
            yield this.repo.checkout(this.branchName);
            yield this.repo.commitTestFile(fileName, msg);
        });
    }
}
exports.TestBranch = TestBranch;
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiR2l0Rmxvd1Rlc3Rlci5qcyIsInNvdXJjZVJvb3QiOiIiLCJzb3VyY2VzIjpbIi4uLy4uL3Rlc3QvR2l0Rmxvd1Rlc3Rlci50cyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7QUFDQSwyQkFBNEI7QUFDNUIsK0JBQThCO0FBQzlCLDJEQUF3RDtBQUd4RCwrQkFBNEI7QUFDNUIsdUNBQXdFO0FBR3hFOztHQUVHO0FBQ0gsTUFBYSxhQUFhO0lBTXhCOzs7OztPQUtHO0lBQ0gsWUFBWSxPQUFnQixFQUFFLFlBQW9CO1FBQ2hELElBQUksQ0FBQyxPQUFPLEdBQUcsT0FBTyxDQUFDO1FBQ3ZCLElBQUksQ0FBQyxJQUFJLEdBQUcsSUFBSSxxQ0FBaUIsQ0FBQztZQUNoQyxXQUFXLEVBQUUsWUFBWTtTQUMxQixDQUFDLENBQUM7SUFDTCxDQUFDO0lBRUQ7O09BRUc7SUFDVSxJQUFJOztZQUNmLE1BQU0sSUFBSSxDQUFDLE9BQU8sRUFBRSxDQUFDO1lBQ3JCLE1BQU0sYUFBYSxDQUFDLGlCQUFpQixDQUFDLElBQUksQ0FBQyxPQUFPLEVBQUUsSUFBSSxDQUFDLElBQUksQ0FBQyxDQUFDO1FBQ2pFLENBQUM7S0FBQTtJQUVEOztPQUVHO0lBQ1UsT0FBTzs7WUFDbEIsTUFBTSxJQUFJLENBQUMsSUFBSSxDQUFDLE1BQU0sRUFBRSxDQUFDO1FBQzNCLENBQUM7S0FBQTtJQUVEOztPQUVHO0lBQ0ksTUFBTSxDQUFPLFVBQVU7O1lBQzVCLE1BQU0sbUJBQVEsQ0FBQyxhQUFhLENBQUMsaUJBQWlCLENBQUMsQ0FBQztZQUNoRCxNQUFNLGdCQUFLLENBQUMsYUFBYSxDQUFDLGlCQUFpQixDQUFDLENBQUM7UUFDL0MsQ0FBQztLQUFBO0lBRUQ7O09BRUc7SUFDVSxhQUFhOztZQUN4QixNQUFNLE9BQU8sR0FBRyxNQUFNLElBQUksQ0FBQyxPQUFPLENBQUMsT0FBTyxFQUFFLENBQUM7WUFDN0MsYUFBTSxDQUFDLEtBQUssQ0FBQyxPQUFPLEVBQUUseUJBQXlCLENB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