"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.AvhGitFlowBranch = void 0;
const log4js_1 = require("log4js");
const AvhBranchListParser_1 = require("../AvhBranchListParser");
const GitFlowBashExecuter_1 = require("../GitFlowBashExecuter");
/**
 * This class implements the basic functionality of a git flow branch.
 */
class AvhGitFlowBranch {
    /**
     * Initializes a new instance of this class.
     *
     * @param repoPath - The path to the git repository.
     */
    constructor(repoPath) {
        this.logger = log4js_1.getLogger('AvhGitFlowBranch');
        this.repositoryPath = repoPath;
    }
    /**
     * {@inheritdoc}
     *
     * @returns The list of the currently opened branch.
     */
    list() {
        return __awaiter(this, void 0, void 0, function* () {
            const output = yield GitFlowBashExecuter_1.GitFlowBashExecuter.execute({
                type: this.type,
                action: 'list',
                repositoryPath: this.repositoryPath,
            });
            return AvhBranchListParser_1.AvhBranchListParser.parse(output);
        });
    }
    /**
     * {@inheritdoc}
     *
     * @param name - Name of the branch to be started.
     * @param base - Base of the branch should be started from.
     * @returns The git reference of the create branch.
     */
    start(name, base) {
        return __awaiter(this, void 0, void 0, function* () {
            let branchName = yield this.getBranchNameFromConfig(name);
            const output = yield GitFlowBashExecuter_1.GitFlowBashExecuter.execute({
                type: this.type,
                action: 'start',
                name: name,
                repositoryPath: this.repositoryPath,
                args: base ? [base] : undefined,
            });
            const matches = output.match(/'([^']+)'/);
            if (matches && matches.groups) {
                if (branchName !== matches.groups[0]) {
                    this.logger.warn(`WARNING: The expected branch name "${branchName}" does not match the actual branch name '${matches.groups[0]}'`);
                }
                branchName = matches.groups[0];
            }
            return branchName;
        });
    }
    /**
     * {@inheritdoc}
     *
     * @param name - Name of the branch to be finished.
     * @param msg - Message to be set for finishing the branch.
     */
    finish(name, msg) {
        return __awaiter(this, void 0, void 0, function* () {
            let options = undefined;
            if (msg) {
                options = `-m ${msg}`;
            }
            const output = yield GitFlowBashExecuter_1.GitFlowBashExecuter.execute({
                type: this.type,
                action: 'finish',
                name: name,
                repositoryPath: this.repositoryPath,
                options: options,
            });
            const outputs = output.trim().split('\n');
            for (const out of outputs) {
                this.logger.info(out);
            }
        });
    }
    /**
     * {@inheritdoc}
     *
     * @param name - A custom name for the branch.
     *
     * @returns The generated branch name.
     */
    generateBranchName(name) {
        return __awaiter(this, void 0, void 0, function* () {
            return name;
        });
    }
    getBranchNameFromConfig(name) {
        var _a;
        return __awaiter(this, void 0, void 0, function* () {
            const config = yield this.getConfig();
            let prefix = (_a = config.prefix) !== null && _a !== void 0 ? _a : this.type;
            if (prefix.endsWith('/')) {
                prefix = prefix.slice(0, -1);
            }
            return `${prefix}/${name}`;
        });
    }
}
exports.AvhGitFlowBranch = AvhGitFlowBranch;
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiQXZoR2l0Rmxvd0JyYW5jaC5qcyIsInNvdXJjZVJvb3QiOiIiLCJzb3VyY2VzIjpbIi4uLy4uLy4uLy4uL3NyYy9hdmgvYnJhbmNoZXMvQXZoR2l0Rmxvd0JyYW5jaC50cyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7QUFBQSxtQ0FBMkM7QUFHM0MsZ0VBQTZEO0FBQzdELGdFQUE2RDtBQUU3RDs7R0FFRztBQUNILE1BQXNCLGdCQUFnQjtJQUlwQzs7OztPQUlHO0lBQ0gsWUFBWSxRQUFpQjtRQVJyQixXQUFNLEdBQVcsa0JBQVMsQ0FBQyxrQkFBa0IsQ0FBQyxDQUFDO1FBU3JELElBQUksQ0FBQyxjQUFjLEdBQUcsUUFBUSxDQUFDO0lBQ2pDLENBQUM7SUFpQkQ7Ozs7T0FJRztJQUNVLElBQUk7O1lBQ2YsTUFBTSxNQUFNLEdBQUcsTUFBTSx5Q0FBbUIsQ0FBQyxPQUFPLENBQUM7Z0JBQy9DLElBQUksRUFBRSxJQUFJLENBQUMsSUFBSTtnQkFDZixNQUFNLEVBQUUsTUFBTTtnQkFDZCxjQUFjLEVBQUUsSUFBSSxDQUFDLGNBQWM7YUFDcEMsQ0FBQyxDQUFDO1lBQ0gsT0FBTyx5Q0FBbUIsQ0FBQyxLQUFLLENBQUMsTUFBTSxDQUFDLENBQUM7UUFDM0MsQ0FBQztLQUFBO0lBRUQ7Ozs7OztPQU1HO0lBQ1UsS0FBSyxDQUFDLElBQWEsRUFBRSxJQUFhOztZQUM3QyxJQUFJLFVBQVUsR0FBRyxNQUFNLElBQUksQ0FBQyx1QkFBdUIsQ0FBQyxJQUFJLENBQUMsQ0FBQztZQUUxRCxNQUFNLE1BQU0sR0FBRyxNQUFNLHlDQUFtQixDQUFDLE9BQU8sQ0FBQztnQkFDL0MsSUFBSSxFQUFFLElBQUksQ0FBQyxJQUFJO2dCQUNmLE1BQU0sRUFBRSxPQUFPO2dCQUNmLElBQUksRUFBRSxJQUFJO2dCQUNWLGNBQWMsRUFBRSxJQUFJLENBQUMsY0FBYztnQkFDbkMsSUFBSSxFQUFFLElBQUksQ0FBQyxDQUFDLENBQUMsQ0FBQyxJQUFJLENBQUMsQ0FBQyxDQUFDLENBQUMsU0FBUzthQUNoQyxDQUFDLENBQUM7WUFFSCxNQUFNLE9BQU8sR0FBRyxNQUFNLENBQUMsS0FBSyxDQUFDLFdBQVcsQ0FBQyxDQUFDO1lBQzFDLElBQUksT0FBTyxJQUFJLE9BQU8sQ0FBQyxNQUFNLEVBQUU7Z0JBQzdCLElBQUksVUFBVSxLQUFLLE9BQU8sQ0FBQyxNQUFNLENBQUMsQ0FBQyxDQUFDLEVBQUU7b0JBQ3BDLElBQUksQ0FBQyxNQUFNLENBQUMsSUFBSSxDQUNkLHNDQUFzQyxVQUFVLDRDQUE0QyxPQUFPLENBQUMsTUFBTSxDQUFDLENBQUMsQ0FBQyxHQUFHLENBQ2pILENBQUM7aUJBQ0g7Z0JBQ0QsVUFBVSxHQUFHLE9BQU8sQ0FBQyxNQUFNLENBQUMsQ0FBQyxDQUFDLENBQUM7YUFDaEM7WUFDRCxPQUFPLFVBQVUsQ0FBQztRQUNwQixDQUFDO0tBQUE7SUFFRDs7Ozs7T0FLRztJQUNVLE1BQU0sQ0FBQyxJQUFhLEVBQUUsR0FBWTs7WUFDN0MsSUFBSSxPQUFPLEdBQXVCLFNBQVMsQ0FBQztZQUM1QyxJQUFJLEdBQUcsRUFBRTtnQkFDUCxPQUFPLEdBQUcsTUFBTSxHQUFHLEVBQUUsQ0FBQzthQUN2QjtZQUNELE1BQU0sTUFBTSxHQUFHLE1BQU0seUNBQW1CLENBQUMsT0FBTyxDQUFDO2dCQUMvQyxJQUFJLEVBQUUsSUFBSSxDQUFDLElBQUk7Z0JBQ2YsTUFBTSxFQUFFLFFBQVE7Z0JBQ2hCLElBQUksRUFBRSxJQUFJO2dCQUNWLGNBQWMsRUFBRSxJQUFJLENBQUMsY0FBYztnQkFDbkMsT0FBTyxFQUFFLE9BQU87YUFDakIsQ0FBQyxDQUFDO1lBQ0gsTUFBTSxPQUFPLEdBQUcsTUFBTSxDQUFDLElBQUksRUFBRSxDQUFDLEtBQUssQ0FBQyxJQUFJLENBQUMsQ0FBQztZQUMxQyxLQUFLLE1BQU0sR0FBRyxJQUFJLE9BQU8sRUFBRTtnQkFDekIsSUFBSSxDQUFDLE1BQU0sQ0FBQyxJQUFJLENBQUMsR0FBRyxDQUFDLENBQUM7YUFDdkI7UUFDSCxDQUFDO0tBQUE7SUFFRDs7Ozs7O09BTUc7SUFDVSxrQkFBa0IsQ0FBQyxJQUFhOztZQUMzQyxPQUFPLElBQUksQ0FBQztRQUNkLENBQUM7S0FBQTtJQUVhLHVCQUF1QixDQUFDLElBQWE7OztZQUNqRCxNQUFNLE1BQU0sR0FBRyxNQUFNLElBQUksQ0FBQyxTQUFTLEVBQUUsQ0FBQztZQUN0QyxJQUFJLE1BQU0sR0FBRyxNQUFBLE1BQU0sQ0FBQyxNQUFNLG1DQUFJLElBQUksQ0FBQyxJQUFJLENBQUM7WUFDeEMsSUFBSSxNQUFNLENBQUMsUUFBUSxDQUFDLEdBQUcsQ0FBQyxFQUFFO2dCQUN4QixNQUFNLEdBQUcsTUFBTSxDQUFDLEtBQUssQ0FBQyxDQUFDLEVBQUUsQ0FBQyxDQUFDLENBQUMsQ0FBQzthQUM5QjtZQUNELE9BQU8sR0FBRyxNQUFNLElBQUksSUFBSSxFQUFFLENBQUM7O0tBQzVCO0NBQ0Y7QUFuSEQsNENBbUhDIn0=