"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.Utils = void 0;
const log4js_1 = require("log4js");
const stream_1 = require("stream");
const ChangelogType_1 = require("../changelog/ChangelogType");
const changelog_1 = require("../changelog");
const conventional_commits_parser_1 = __importDefault(require("conventional-commits-parser"));
/**
 * Provides some utility functions.
 */
class Utils {
    /**
     * Gets the current date formatted as yyyy-mm-dd.
     *
     * @returns date in fomat yyyy-mm-dd.
     */
    static getCurrDate() {
        const today = new Date();
        const yyyy = today.getFullYear();
        let dd = '' + today.getDate();
        let mm = '' + (today.getMonth() + 1);
        if (+dd < 10) {
            dd = '0' + dd;
        }
        if (+mm < 10) {
            mm = '0' + mm;
        }
        return `${yyyy}-${mm}-${dd}`;
    }
    /**
     * Executes a command and suppresses errors if they are thrown.
     *
     * @param command - Command to be executed.
     */
    static exec(command) {
        return __awaiter(this, void 0, void 0, function* () {
            try {
                yield command();
            }
            catch (error) {
                const logger = log4js_1.getLogger('gitex-flow');
                logger.error(error);
            }
        });
    }
    /**
     * Prints the config to the console.
     *
     * @param gitFlow - The git flow instance the config should be printed.
     */
    static printConfig(gitFlow) {
        return __awaiter(this, void 0, void 0, function* () {
            const branches = yield gitFlow.config.get();
            console.info(branches);
        });
    }
    /**
     * Prints the branches to the console.
     *
     * @param gitFlowBranch - The branch type to be printed.
     */
    static printBranches(gitFlowBranch) {
        return __awaiter(this, void 0, void 0, function* () {
            const branches = yield gitFlowBranch.list();
            if (branches.length === 0) {
                console.error(`There are no active ${gitFlowBranch.type} branches.`);
            }
            else {
                console.info(`Active ${gitFlowBranch.type} branches:`);
                for (const branch of branches) {
                    console.info(` - ${branch}`);
                }
            }
        });
    }
    /**
     * Pipes a readable stream asynchrounously to a writable stream with error handling.
     *
     * @param src - The readable source stream.
     * @param dest - The writable destination stream.
     * @param destroy - Specifies if the streams should be destroyed on finish.
     *
     * @returns Promise on copying stream properly.
     */
    static pipe(src, dest, destroy = true) {
        return new Promise((resolve, reject) => {
            src
                .on('error', (err) => {
                err.message = `Error on reading source stream: ${err.message}`;
                reject(err);
            })
                .pipe(dest)
                .on('error', (err) => {
                err.message = `Error on writing destination stream: ${err.message}`;
                reject(err);
            })
                .on('finish', () => {
                if (destroy) {
                    src.destroy();
                    dest.destroy();
                }
                resolve();
            });
        });
    }
    /**
     * Derives the [[ChangelogConfig]] from a given [[projectConfig]].
     *
     * @param projectConfig - The project configuration.
     *
     * @returns The derived changelog config.
     */
    static deriveChangelogConfig(projectConfig) {
        var _a, _b, _c, _d, _e, _f, _g, _h, _j;
        const config = (_a = projectConfig === null || projectConfig === void 0 ? void 0 : projectConfig.changelog) !== null && _a !== void 0 ? _a : {
            basePath: (_b = projectConfig === null || projectConfig === void 0 ? void 0 : projectConfig.projectPath) !== null && _b !== void 0 ? _b : process.cwd(),
            type: ChangelogType_1.ChangelogType.ConventionalChangelog,
        };
        config.basePath = (_d = (_c = config.basePath) !== null && _c !== void 0 ? _c : projectConfig === null || projectConfig === void 0 ? void 0 : projectConfig.projectPath) !== null && _d !== void 0 ? _d : process.cwd();
        // Following lines are ensuring backward compatibility to avoid a breaking change for version 2.3.
        config.changelogFileName =
            (_f = (_e = projectConfig === null || projectConfig === void 0 ? void 0 : projectConfig.changelogFileName) !== null && _e !== void 0 ? _e : config.changelogFileName) !== null && _f !== void 0 ? _f : changelog_1.ChangelogWriter.DefaultChangelogFile;
        config.storeLatestChangelog = (_g = projectConfig === null || projectConfig === void 0 ? void 0 : projectConfig.storeLatestChangelog) !== null && _g !== void 0 ? _g : config.storeLatestChangelog;
        if (config.type == ChangelogType_1.ChangelogType.ConventionalChangelog) {
            const conf = config;
            conf.conventionalChangelogPresent =
                (_j = (_h = projectConfig === null || projectConfig === void 0 ? void 0 : projectConfig.conventionalChangelogPresent) !== null && _h !== void 0 ? _h : conf.conventionalChangelogPresent) !== null && _j !== void 0 ? _j : 'angular';
        }
        return config;
    }
    /**
     * Parses conventional commit messages to a [[GitLog]] array.
     *
     * @param commitMessages - The commit messages.
     * @param conventionalCommitConfig - The configuration of the conventional commit parser.
     * @returns The parsed conventional commit messages as an array of [[GitLogs]].
     */
    static parseConventionalCommits(commitMessages, conventionalCommitConfig) {
        return __awaiter(this, void 0, void 0, function* () {
            const gitLogs = [];
            const stream = stream_1.Readable.from(commitMessages);
            return new Promise((resolve, reject) => {
                stream
                    .pipe(Utils.parseConventionalCommitsViaPipe(conventionalCommitConfig))
                    .on('error', function (err) {
                    err.message = 'Error in conventional-commits-parser: ' + err.message;
                    reject(err);
                })
                    .on('data', (data) => {
                    const log = data;
                    gitLogs.push(log);
                })
                    .on('end', () => {
                    resolve(gitLogs);
                });
            });
        });
    }
    /**
     * Parses conventional commit messages via a stream.Transform pipe.
     *
     * @param conventionalCommitConfig - The configuration of the conventional commit parser.
     * @returns The parsed conventional commit messages as transformed stream.
     */
    static parseConventionalCommitsViaPipe(conventionalCommitConfig) {
        return conventional_commits_parser_1.default(conventionalCommitConfig !== null && conventionalCommitConfig !== void 0 ? conventionalCommitConfig : {
            referenceActions: [
                'close',
                'closes',
                'closed',
                'fix',
                'fixes',
                'fixed',
                'resolve',
                'resolves',
                'resolved',
                'refs',
                'references',
            ],
            noteKeywords: ['BREAKING CHANGE', 'SECURITY', 'REMOVED'],
        });
    }
}
exports.Utils = Utils;
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiVXRpbHMuanMiLCJzb3VyY2VSb290IjoiIiwic291cmNlcyI6WyIuLi8uLi8uLi9zcmMvdG9vbHMvVXRpbHMudHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7O0FBQUEsbUNBQW1DO0FBR25DLG1DQUF1RDtBQUd2RCw4REFBMkQ7QUFFM0QsNENBQStDO0FBQy9DLDhGQUFvRTtBQUdwRTs7R0FFRztBQUNILE1BQWEsS0FBSztJQUNoQjs7OztPQUlHO0lBQ0ksTUFBTSxDQUFDLFdBQVc7UUFDdkIsTUFBTSxLQUFLLEdBQUcsSUFBSSxJQUFJLEVBQUUsQ0FBQztRQUN6QixNQUFNLElBQUksR0FBRyxLQUFLLENBQUMsV0FBVyxFQUFFLENBQUM7UUFDakMsSUFBSSxFQUFFLEdBQUcsRUFBRSxHQUFHLEtBQUssQ0FBQyxPQUFPLEVBQUUsQ0FBQztRQUM5QixJQUFJLEVBQUUsR0FBRyxFQUFFLEdBQUcsQ0FBQyxLQUFLLENBQUMsUUFBUSxFQUFFLEdBQUcsQ0FBQyxDQUFDLENBQUM7UUFDckMsSUFBSSxDQUFDLEVBQUUsR0FBRyxFQUFFLEVBQUU7WUFDWixFQUFFLEdBQUcsR0FBRyxHQUFHLEVBQUUsQ0FBQztTQUNmO1FBQ0QsSUFBSSxDQUFDLEVBQUUsR0FBRyxFQUFFLEVBQUU7WUFDWixFQUFFLEdBQUcsR0FBRyxHQUFHLEVBQUUsQ0FBQztTQUNmO1FBQ0QsT0FBTyxHQUFHLElBQUksSUFBSSxFQUFFLElBQUksRUFBRSxFQUFFLENBQUM7SUFDL0IsQ0FBQztJQUVEOzs7O09BSUc7SUFDSSxNQUFNLENBQU8sSUFBSSxDQUFDLE9BQXFDOztZQUM1RCxJQUFJO2dCQUNGLE1BQU0sT0FBTyxFQUFFLENBQUM7YUFDakI7WUFBQyxPQUFPLEtBQUssRUFBRTtnQkFDZCxNQUFNLE1BQU0sR0FBRyxrQkFBUyxDQUFDLFlBQVksQ0FBQyxDQUFDO2dCQUN2QyxNQUFNLENBQUMsS0FBSyxDQUFDLEtBQUssQ0FBQyxDQUFDO2FBQ3JCO1FBQ0gsQ0FBQztLQUFB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