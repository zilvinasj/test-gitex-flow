"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.GitFlowSemVers = void 0;
const semver_1 = require("semver");
const GitRepository_1 = require("../git/GitRepository");
/**
 * Representing an API for handling git flow SemVer.
 */
class GitFlowSemVers {
    /**
     * Initializes a new instance of this class.
     *
     * @param basePath - Base path of the project folder.
     */
    constructor(basePath) {
        this.basePath = basePath !== null && basePath !== void 0 ? basePath : process.cwd();
    }
    /**
     * Calculates the version of the branch created from the current branch.
     *
     * @param type - Type of the branch should be created.
     * @param version - A optional custom version to be used.
     *
     * @returns The calculated branch version.
     */
    calculateBranchVersion(type, version) {
        var _a;
        return __awaiter(this, void 0, void 0, function* () {
            if (type == 'hotfix' || type == 'release') {
                if (version) {
                    version = (_a = semver_1.valid(semver_1.clean(version))) !== null && _a !== void 0 ? _a : undefined;
                }
                else {
                    const gitRepository = new GitRepository_1.GitRepository({
                        projectPath: this.basePath,
                    });
                    const latestVersion = yield gitRepository.getLatestReleasedVersion();
                    if (!latestVersion) {
                        version = '1.0.0';
                    }
                    else {
                        let releaseType = 'patch';
                        if (type == 'release') {
                            if (yield this.hasBreakingChanges()) {
                                releaseType = 'major';
                            }
                            else {
                                releaseType = 'minor';
                            }
                        }
                        version = semver_1.inc(latestVersion, releaseType);
                    }
                }
            }
            return version;
        });
    }
    hasBreakingChanges() {
        return __awaiter(this, void 0, void 0, function* () {
            const gitRepository = new GitRepository_1.GitRepository({
                projectPath: this.basePath,
            });
            const gitLogs = yield gitRepository.getLogsSinceLastRelease();
            const hasBreakingChanges = gitLogs.some((log) => log.notes.some((x) => x.title === 'BREAKING CHANGE'));
            return hasBreakingChanges;
        });
    }
}
exports.GitFlowSemVers = GitFlowSemVers;
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiR2l0Rmxvd1NlbVZlcnMuanMiLCJzb3VyY2VSb290IjoiIiwic291cmNlcyI6WyIuLi8uLi8uLi9zcmMvdG9vbHMvR2l0Rmxvd1NlbVZlcnMudHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7O0FBQ0EsbUNBQXdEO0FBQ3hELHdEQUFxRDtBQUdyRDs7R0FFRztBQUNILE1BQWEsY0FBYztJQUd6Qjs7OztPQUlHO0lBQ0gsWUFBWSxRQUFpQjtRQUMzQixJQUFJLENBQUMsUUFBUSxHQUFHLFFBQVEsYUFBUixRQUFRLGNBQVIsUUFBUSxHQUFJLE9BQU8sQ0FBQyxHQUFHLEVBQUUsQ0FBQztJQUM1QyxDQUFDO0lBRUQ7Ozs7Ozs7T0FPRztJQUNVLHNCQUFzQixDQUFDLElBQXVCLEVBQUUsT0FBZ0I7OztZQUMzRSxJQUFJLElBQUksSUFBSSxRQUFRLElBQUksSUFBSSxJQUFJLFNBQVMsRUFBRTtnQkFDekMsSUFBSSxPQUFPLEVBQUU7b0JBQ1gsT0FBTyxHQUFHLE1BQUEsY0FBSyxDQUFDLGNBQUssQ0FBQyxPQUFPLENBQUMsQ0FBQyxtQ0FBSSxTQUFTLENBQUM7aUJBQzlDO3FCQUFNO29CQUNMLE1BQU0sYUFBYSxHQUFHLElBQUksNkJBQWEsQ0FBQzt3QkFDdEMsV0FBVyxFQUFFLElBQUksQ0FBQyxRQUFRO3FCQUMzQixDQUFDLENBQUM7b0JBQ0gsTUFBTSxhQUFhLEdBQUcsTUFBTSxhQUFhLENBQUMsd0JBQXdCLEVBQUUsQ0FBQztvQkFDckUsSUFBSSxDQUFDLGFBQWEsRUFBRTt3QkFDbEIsT0FBTyxHQUFHLE9BQU8sQ0FBQztxQkFDbkI7eUJBQU07d0JBQ0wsSUFBSSxXQUFXLEdBQWdCLE9BQU8sQ0FBQzt3QkFDdkMsSUFBSSxJQUFJLElBQUksU0FBUyxFQUFFOzRCQUNyQixJQUFJLE1BQU0sSUFBSSxDQUFDLGtCQUFrQixFQUFFLEVBQUU7Z0NBQ25DLFdBQVcsR0FBRyxPQUFPLENBQUM7NkJBQ3ZCO2lDQUFNO2dDQUNMLFdBQVcsR0FBRyxPQUFPLENBQUM7NkJBQ3ZCO3lCQUNGO3dCQUNELE9BQU8sR0FBRyxZQUFHLENBQUMsYUFBYSxFQUFFLFdBQVcsQ0FBVyxDQUFDO3FCQUNyRDtpQkFDRjthQUNGO1lBQ0QsT0FBTyxPQUFPLENBQUM7O0tBQ2hCO0lBRWEsa0JBQWtCOztZQUM5QixNQUFNLGFBQWEsR0FBRyxJQUFJLDZCQUFhLENBQUM7Z0JBQ3RDLFdBQVcsRUFBRSxJQUFJLENBQUMsUUFBUTthQUMzQixDQUFDLENBQUM7WUFDSCxNQUFNLE9BQU8sR0FBRyxNQUFNLGFBQWEsQ0FBQyx1QkFBdUIsRUFBRSxDQUFDO1lBQzlELE1BQU0sa0JBQWtCLEdBQUcsT0FBTyxDQUFDLElBQUksQ0FBQyxDQUFDLEdBQVcsRUFBRSxFQUFFLENBQUMsR0FBRyxDQUFDLEtBQUssQ0FBQyxJQUFJLENBQUMsQ0FBQyxDQUFDLEVBQUUsRUFBRSxDQUFDLENBQUMsQ0FBQyxLQUFLLEtBQUssaUJBQWlCLENBQUMsQ0FBQyxDQUFDO1lBQy9HLE9BQU8sa0JBQWtCLENBQUM7UUFDNUIsQ0FBQztLQUFBO0NBQ0Y7QUF2REQsd0NBdURDIn0=