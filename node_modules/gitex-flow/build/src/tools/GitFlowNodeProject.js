"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.GitFlowNodeProject = void 0;
const path_1 = require("path");
const GitRepository_1 = require("../git/GitRepository");
const fs_extra_1 = require("fs-extra");
const Utils_1 = require("./Utils");
const write_json_file_1 = __importDefault(require("write-json-file"));
const log4js_1 = require("log4js");
const ChangelogWriter_1 = require("../changelog/ChangelogWriter");
const ChangelogWriterFactory_1 = require("../changelog/ChangelogWriterFactory");
/**
 * Representing an API for handling git flow SemVer.
 */
class GitFlowNodeProject {
    /**
     * Initializes a new instance of this class.
     *
     * @param options - Options of the git flow node project instance.
     */
    constructor(options) {
        var _a, _b, _c;
        this.logger = log4js_1.getLogger('GitFlowNodeProject');
        if (!options)
            options = { projectPath: process.cwd() };
        options.projectPath = (_a = options.projectPath) !== null && _a !== void 0 ? _a : process.cwd();
        this.options = options;
        this.options.versionFile = (_b = this.options.versionFile) !== null && _b !== void 0 ? _b : GitFlowNodeProject.DefaultVersionFile;
        this.options.bumpVersionFiles = (_c = options.bumpVersionFiles) !== null && _c !== void 0 ? _c : GitFlowNodeProject.DefaultBumpVersionFiles;
        this.options.changelog = Utils_1.Utils.deriveChangelogConfig(this.options);
        this.gitRepository = new GitRepository_1.GitRepository(options);
    }
    /**
     * Checks out the given branch of the project.
     *
     * @param branchName - Name of the branch to be checked out.
     */
    checkoutBranch(branchName) {
        return __awaiter(this, void 0, void 0, function* () {
            yield this.gitRepository.ensureNoUnCommitedChanges();
            yield this.gitRepository.checkout(branchName);
        });
    }
    /**
     * Stashes the uncommited changes from the current branch.
     *
     * @returns `true` if stash was successful, otherwise `false`.
     */
    stash() {
        return __awaiter(this, void 0, void 0, function* () {
            const status = yield this.gitRepository.status();
            let stashMessage = undefined;
            if (!status.isClean()) {
                stashMessage = yield this.gitRepository.stash();
            }
            return stashMessage !== undefined;
        });
    }
    /**
     * Pops the latest stash.
     *
     * @returns Promise on popping the latest stash.
     */
    popLatestStash() {
        return __awaiter(this, void 0, void 0, function* () {
            return this.gitRepository.popLatestStash();
        });
    }
    /**
     * Gets the current branch.
     *
     * @returns The current branch checked out.
     */
    getCurrentBranch() {
        var _a;
        return __awaiter(this, void 0, void 0, function* () {
            const status = yield this.gitRepository.status();
            return (_a = status.current) !== null && _a !== void 0 ? _a : '';
        });
    }
    /**
     *  Writes the version and commits the changes in the git repository.
     *
     * @param version - Version to commit.
     */
    writeVersion(version) {
        return __awaiter(this, void 0, void 0, function* () {
            const versionFiles = this.options.bumpVersionFiles;
            for (const versionFile of versionFiles) {
                yield this.writeVersionToFile(versionFile, version);
            }
            this.logger.info(`Updated versions in ${versionFiles.join(' and ')} to ${version}`);
        });
    }
    /**
     * Updates the changelog with the changes since the last release.
     *
     * @param changelogConfig - The changelog configuration.
     * @param version - Version the changelog is created for.
     * @param name - Name of the release.
     */
    updateChangelog(changelogConfig, version, name) {
        return __awaiter(this, void 0, void 0, function* () {
            const changelogWriter = ChangelogWriterFactory_1.ChangelogWriterFactory.create(changelogConfig);
            if (changelogWriter) {
                const logs = yield this.gitRepository.getLogsSinceLastRelease();
                version = version !== null && version !== void 0 ? version : (yield this.getVersion());
                const context = yield this.getContext(version, name);
                yield changelogWriter.write(context, logs);
            }
        });
    }
    /**
     * Commits the changes of the git repository.
     *
     * @param commitVersionFiles - Indicates if the defined version files should be committed if they exists.
     * @param commitChangelog - Indicates if the changelog should be committed.
     *
     * @returns The hash of the commit.
     */
    commitChanges(commitVersionFiles = true, commitChangelog = true) {
        var _a;
        return __awaiter(this, void 0, void 0, function* () {
            const updateDescs = [];
            const files = [];
            if (commitVersionFiles) {
                updateDescs.push('version');
                const versionFiles = this.options.bumpVersionFiles;
                for (const versionFile of versionFiles) {
                    const versionFilePath = path_1.join(this.options.projectPath, versionFile);
                    if (yield fs_extra_1.pathExists(versionFilePath)) {
                        files.push(versionFile);
                    }
                }
            }
            if (commitChangelog) {
                updateDescs.push('changelog');
                const changelog = (_a = this.options.changelog) === null || _a === void 0 ? void 0 : _a.changelogFileName;
                const changelogPath = path_1.join(this.options.projectPath, changelog);
                if (yield fs_extra_1.pathExists(changelogPath)) {
                    files.push(changelog);
                }
                const latestChangelogName = ChangelogWriter_1.ChangelogWriter.getLatestChangelogName(changelog);
                const latestChangelogPath = path_1.join(this.options.projectPath, latestChangelogName);
                if (yield fs_extra_1.pathExists(latestChangelogPath)) {
                    files.push(latestChangelogPath);
                }
            }
            const commitMsg = `chore(release): Updated ${updateDescs.join(' and ')}`;
            return this.gitRepository.commit(files, commitMsg);
        });
    }
    /**
     * Gets the current version from the package.json.
     *
     * @returns The version of the project.
     */
    getVersion() {
        return __awaiter(this, void 0, void 0, function* () {
            const versionFile = this.options.versionFile;
            const packageJson = yield fs_extra_1.readJson(path_1.join(this.options.projectPath, versionFile));
            return packageJson.version;
        });
    }
    writeVersionToFile(fileName, version) {
        return __awaiter(this, void 0, void 0, function* () {
            const filePath = path_1.join(this.options.projectPath, fileName);
            if (yield fs_extra_1.pathExists(filePath)) {
                const packageJson = yield fs_extra_1.readJson(filePath);
                packageJson.version = version;
                yield write_json_file_1.default(filePath, packageJson, { detectIndent: true });
            }
        });
    }
    getContext(version, name) {
        var _a;
        return __awaiter(this, void 0, void 0, function* () {
            const versionFile = this.options.versionFile;
            const packageJson = yield fs_extra_1.readJson(path_1.join(this.options.projectPath, versionFile));
            const repoUrl = ((_a = packageJson === null || packageJson === void 0 ? void 0 : packageJson.repository) === null || _a === void 0 ? void 0 : _a.url) ? new URL(packageJson.repository.url) : undefined;
            const host = repoUrl ? `https://${repoUrl.host}` : undefined;
            let path = repoUrl === null || repoUrl === void 0 ? void 0 : repoUrl.pathname;
            if (path === null || path === void 0 ? void 0 : path.endsWith('.git')) {
                path = path.substring(0, path.length - 4);
            }
            const url = repoUrl ? `https://${repoUrl.host}${path}` : undefined;
            return {
                version: version,
                title: name,
                host: host,
                repoUrl: url,
                commit: 'commits',
                issue: 'issues',
                date: Utils_1.Utils.getCurrDate(),
            };
        });
    }
}
exports.GitFlowNodeProject = GitFlowNodeProject;
GitFlowNodeProject.DefaultVersionFile = 'package.json';
GitFlowNodeProject.DefaultBumpVersionFiles = [GitFlowNodeProject.DefaultVersionFile, 'package-lock.json'];
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiR2l0Rmxvd05vZGVQcm9qZWN0LmpzIiwic291cmNlUm9vdCI6IiIsInNvdXJjZXMiOlsiLi4vLi4vLi4vc3JjL3Rvb2xzL0dpdEZsb3dOb2RlUHJvamVjdC50cyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7QUFBQSwrQkFBNEI7QUFDNUIsd0RBQXFEO0FBQ3JELHVDQUFnRDtBQUNoRCxtQ0FBZ0M7QUFDaEMsc0VBQTRDO0FBQzVDLG1DQUFtQztBQUNuQyxrRUFBK0Q7QUFJL0QsZ0ZBQTZFO0FBRTdFOztHQUVHO0FBQ0gsTUFBYSxrQkFBa0I7SUFTN0I7Ozs7T0FJRztJQUNILFlBQVksT0FBdUI7O1FBYmxCLFdBQU0sR0FBRyxrQkFBUyxDQUFDLG9CQUFvQixDQUFDLENBQUM7UUFjeEQsSUFBSSxDQUFDLE9BQU87WUFBRSxPQUFPLEdBQUcsRUFBRSxXQUFXLEVBQUUsT0FBTyxDQUFDLEdBQUcsRUFBRSxFQUFFLENBQUM7UUFDdkQsT0FBTyxDQUFDLFdBQVcsR0FBRyxNQUFBLE9BQU8sQ0FBQyxXQUFXLG1DQUFJLE9BQU8sQ0FBQyxHQUFHLEVBQUUsQ0FBQztRQUMzRCxJQUFJLENBQUMsT0FBTyxHQUFHLE9BQU8sQ0FBQztRQUN2QixJQUFJLENBQUMsT0FBTyxDQUFDLFdBQVcsR0FBRyxNQUFBLElBQUksQ0FBQyxPQUFPLENBQUMsV0FBVyxtQ0FBSSxrQkFBa0IsQ0FBQyxrQkFBa0IsQ0FBQztRQUM3RixJQUFJLENBQUMsT0FBTyxDQUFDLGdCQUFnQixHQUFHLE1BQUEsT0FBTyxDQUFDLGdCQUFnQixtQ0FBSSxrQkFBa0IsQ0FBQyx1QkFBdUIsQ0FBQztRQUN2RyxJQUFJLENBQUMsT0FBTyxDQUFDLFNBQVMsR0FBRyxhQUFLLENBQUMscUJBQXFCLENBQUMsSUFBSSxDQUFDLE9BQU8sQ0FBQyxDQUFDO1FBQ25FLElBQUksQ0FBQyxhQUFhLEdBQUcsSUFBSSw2QkFBYSxDQUFDLE9BQU8sQ0FBQyxDQUFDO0lBQ2xELENBQUM7SUFFRDs7OztP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