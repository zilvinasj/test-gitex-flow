"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.GFlowHotFixBranch = void 0;
const GitFlowNodeProject_1 = require("../../tools/GitFlowNodeProject");
const GFlowBranch_1 = require("./GFlowBranch");
const Utils_1 = require("../../tools/Utils");
/**
 * This class extending a hotfix branch with some helpful functionality.
 */
class GFlowHotFixBranch extends GFlowBranch_1.GFlowBranch {
    /**
     * Initializes a new instance of this class.
     *
     * @param gitFlowBranch - Git flow branch to be wrapped.
     * @param options - Git flow node project options.
     */
    constructor(gitFlowBranch, options) {
        super(gitFlowBranch, options);
    }
    /**
     * Creates and starts a new hotfix branch.
     *
     * @param name - Name of the branch to be started.
     * @param base - Base of the branch should be started from.
     *
     * @returns The name of the hotfix branch.
     */
    start(name, base) {
        const _super = Object.create(null, {
            stashChanges: { get: () => super.stashChanges },
            start: { get: () => super.start }
        });
        return __awaiter(this, void 0, void 0, function* () {
            const version = yield this.generateBranchName(name);
            if (!version) {
                throw new Error('Failed to calculate the version from the current repository.');
            }
            const project = new GitFlowNodeProject_1.GitFlowNodeProject(this.projectConfig);
            const stashed = yield _super.stashChanges.call(this, project);
            const branch = yield _super.start.call(this, version, base);
            yield project.writeVersion(version);
            yield project.commitChanges(true, false);
            if (stashed) {
                yield this.popStashedChanges(project);
            }
            return branch;
        });
    }
    /**
     * Merges and finishes the branch of the branch type '[[type]]'.
     *
     * @param name - Name of the branch to be finished.
     * @param msg - Message to be set for finishing the branch.
     */
    finish(name, msg) {
        const _super = Object.create(null, {
            finish: { get: () => super.finish }
        });
        return __awaiter(this, void 0, void 0, function* () {
            const project = new GitFlowNodeProject_1.GitFlowNodeProject(this.projectConfig);
            const version = yield this.getVersion(project, name);
            const branchName = yield this.generateBranchNameFromConfig(version);
            yield project.checkoutBranch(branchName);
            const changelogConfig = Utils_1.Utils.deriveChangelogConfig(this.projectConfig);
            yield project.updateChangelog(changelogConfig);
            yield project.commitChanges(false);
            yield _super.finish.call(this, version, msg !== null && msg !== void 0 ? msg : version);
        });
    }
    getVersion(project, name) {
        return __awaiter(this, void 0, void 0, function* () {
            let version = name;
            if (!version) {
                const hotfixBranches = yield this.list();
                if (hotfixBranches.length == 0) {
                    version = yield project.getVersion();
                }
                // There is only one hotfix branch
                version = hotfixBranches[0];
            }
            return version;
        });
    }
}
exports.GFlowHotFixBranch = GFlowHotFixBranch;
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiR0Zsb3dIb3RGaXhCcmFuY2guanMiLCJzb3VyY2VSb290IjoiIiwic291cmNlcyI6WyIuLi8uLi8uLi8uLi9zcmMvZ2Zsb3cvYnJhbmNoZXMvR0Zsb3dIb3RGaXhCcmFuY2gudHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7O0FBQ0EsdUVBQW9FO0FBRXBFLCtDQUE0QztBQUM1Qyw2Q0FBMEM7QUFFMUM7O0dBRUc7QUFDSCxNQUFhLGlCQUFrQixTQUFRLHlCQUFXO0lBQ2hEOzs7OztPQUtHO0lBQ0gsWUFBWSxhQUE0QixFQUFFLE9BQXVCO1FBQy9ELEtBQUssQ0FBQyxhQUFhLEVBQUUsT0FBTyxDQUFDLENBQUM7SUFDaEMsQ0FBQztJQUVEOzs7Ozs7O09BT0c7SUFDVSxLQUFLLENBQUMsSUFBYSxFQUFFLElBQWE7Ozs7OztZQUM3QyxNQUFNLE9BQU8sR0FBRyxNQUFNLElBQUksQ0FBQyxrQkFBa0IsQ0FBQyxJQUFJLENBQUMsQ0FBQztZQUNwRCxJQUFJLENBQUMsT0FBTyxFQUFFO2dCQUNaLE1BQU0sSUFBSSxLQUFLLENBQUMsOERBQThELENBQUMsQ0FBQzthQUNqRjtZQUNELE1BQU0sT0FBTyxHQUFHLElBQUksdUNBQWtCLENBQUMsSUFBSSxDQUFDLGFBQWEsQ0FBQyxDQUFDO1lBQzNELE1BQU0sT0FBTyxHQUFHLE1BQU0sT0FBTSxZQUFZLFlBQUMsT0FBTyxDQUFDLENBQUM7WUFDbEQsTUFBTSxNQUFNLEdBQUcsTUFBTSxPQUFNLEtBQUssWUFBQyxPQUFPLEVBQUUsSUFBSSxDQUFDLENBQUM7WUFDaEQsTUFBTSxPQUFPLENBQUMsWUFBWSxDQUFDLE9BQU8sQ0FBQyxDQUFDO1lBQ3BDLE1BQU0sT0FBTyxDQUFDLGFBQWEsQ0FBQyxJQUFJLEVBQUUsS0FBSyxDQUFDLENBQUM7WUFDekMsSUFBSSxPQUFPLEVBQUU7Z0JBQ1gsTUFBTSxJQUFJLENBQUMsaUJBQWlCLENBQUMsT0FBTyxDQUFDLENBQUM7YUFDdkM7WUFDRCxPQUFPLE1BQU0sQ0FBQztRQUNoQixDQUFDO0tBQUE7SUFFRDs7Ozs7T0FLRztJQUNVLE1BQU0sQ0FBQyxJQUFhLEVBQUUsR0FBWTs7Ozs7WUFDN0MsTUFBTSxPQUFPLEdBQUcsSUFBSSx1Q0FBa0IsQ0FBQyxJQUFJLENBQUMsYUFBYSxDQUFDLENBQUM7WUFDM0QsTUFBTSxPQUFPLEdBQUcsTUFBTSxJQUFJLENBQUMsVUFBVSxDQUFDLE9BQU8sRUFBRSxJQUFJLENBQUMsQ0FBQztZQUNyRCxNQUFNLFVBQVUsR0FBRyxNQUFNLElBQUksQ0FBQyw0QkFBNEIsQ0FBQyxPQUFPLENBQUMsQ0FBQztZQUNwRSxNQUFNLE9BQU8sQ0FBQyxjQUFjLENBQUMsVUFBVSxDQUFDLENBQUM7WUFDekMsTUFBTSxlQUFlLEdBQUcsYUFBSyxDQUFDLHFCQUFxQixDQUFDLElBQUksQ0FBQyxhQUFhLENBQUMsQ0FBQztZQUN4RSxNQUFNLE9BQU8sQ0FBQyxlQUFlLENBQUMsZUFBZSxDQUFDLENBQUM7WUFDL0MsTUFBTSxPQUFPLENBQUMsYUFBYSxDQUFDLEtBQUssQ0FBQyxDQUFDO1lBQ25DLE1BQU0sT0FBTSxNQUFNLFlBQUMsT0FBTyxFQUFFLEdBQUcsYUFBSCxHQUFHLGNBQUgsR0FBRyxHQUFJLE9BQU8sQ0FBQyxDQUFDO1FBQzlDLENBQUM7S0FBQTtJQUVhLFVBQVUsQ0FBQyxPQUEyQixFQUFFLElBQWE7O1lBQ2pFLElBQUksT0FBTyxHQUFHLElBQUksQ0FBQztZQUNuQixJQUFJLENBQUMsT0FBTyxFQUFFO2dCQUNaLE1BQU0sY0FBYyxHQUFHLE1BQU0sSUFBSSxDQUFDLElBQUksRUFBRSxDQUFDO2dCQUN6QyxJQUFJLGNBQWMsQ0FBQyxNQUFNLElBQUksQ0FBQyxFQUFFO29CQUM5QixPQUFPLEdBQUcsTUFBTSxPQUFPLENBQUMsVUFBVSxFQUFFLENBQUM7aUJBQ3RDO2dCQUNELGtDQUFrQztnQkFDbEMsT0FBTyxHQUFHLGNBQWMsQ0FBQyxDQUFDLENBQUMsQ0FBQzthQUM3QjtZQUNELE9BQU8sT0FBTyxDQUFDO1FBQ2pCLENBQUM7S0FBQTtDQUNGO0FBaEVELDhDQWdFQyJ9