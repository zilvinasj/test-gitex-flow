"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.GFlowBranch = void 0;
const log4js_1 = require("log4js");
const GitFlowNodeProject_1 = require("../../tools/GitFlowNodeProject");
const GitFlowSemVers_1 = require("../../tools/GitFlowSemVers");
/**
 * This class represents an abstract GFlow branch with some basic functionality.
 */
class GFlowBranch {
    /**
     * Initializes a new instance of this class.
     *
     * @param gitFlowBranch - Git flow branch to be wrapped.
     * @param options - Git flow node project options.
     */
    constructor(gitFlowBranch, options) {
        this.gitFlowBranch = gitFlowBranch;
        this.projectConfig = options;
        this.type = this.gitFlowBranch.type;
        this.defaultBase = this.gitFlowBranch.defaultBase;
        this.logger = log4js_1.getLogger(`gitex-flow [${this.type}]`);
    }
    /**
     * Gets the git flow branch config.
     *
     * @returns The configuration of the gitex flow branch.
     */
    getConfig() {
        return __awaiter(this, void 0, void 0, function* () {
            return yield this.gitFlowBranch.getConfig();
        });
    }
    /**
     * Lists all branches of the type '[[type]]'.
     *
     * @returns The list of branches.
     */
    list() {
        return __awaiter(this, void 0, void 0, function* () {
            return yield this.gitFlowBranch.list();
        });
    }
    /**
     * Creates and starts a new branch of the type '[[type]]'.
     *
     * @param name - Name of the branch to be started.
     * @param base - Base of the branch should be started from.
     *
     * @returns The name of the started branch.
     */
    start(name, base) {
        return __awaiter(this, void 0, void 0, function* () {
            const project = new GitFlowNodeProject_1.GitFlowNodeProject(this.projectConfig);
            this.logger.info(`Starting ${this.type} branch "${name}" based on "${base !== null && base !== void 0 ? base : this.defaultBase}"`);
            name = yield this.generateBranchName(name);
            const stashed = yield this.stashChanges(project);
            const branch = yield this.gitFlowBranch.start(name, base);
            if (stashed) {
                yield this.popStashedChanges(project);
            }
            this.logger.info(`Created branch "${branch}"`);
            return branch;
        });
    }
    /**
     * Merges and finishes the branch of the branch type '[[type]]'.
     *
     * @param name - Name of the branch to be finished.
     * @param msg - Message to be set for finishing the branch.
     */
    finish(name, msg) {
        return __awaiter(this, void 0, void 0, function* () {
            const project = new GitFlowNodeProject_1.GitFlowNodeProject(this.projectConfig);
            if (!name) {
                name = yield project.getCurrentBranch();
                name = name.substr(name.indexOf('/') + 1);
            }
            this.logger.info(`Finishing ${this.type} branch "${name}"`);
            yield this.gitFlowBranch.finish(name, msg);
            const branchName = yield this.generateBranchNameFromConfig(name !== null && name !== void 0 ? name : '');
            this.logger.info(`Merged branch "${branchName}"`);
        });
    }
    /**
     * Generates an default branch name.
     *
     * @param name - A custom name for the branch.
     *
     * @returns The generated branch name.
     */
    generateBranchName(name) {
        var _a;
        return __awaiter(this, void 0, void 0, function* () {
            const semVer = new GitFlowSemVers_1.GitFlowSemVers((_a = this.projectConfig) === null || _a === void 0 ? void 0 : _a.projectPath);
            return semVer.calculateBranchVersion(this.type, name);
        });
    }
    /**
     * Gets the branch name including the git-flow configuration.
     *
     * @param name - A given branch name without prefix.
     *
     * @returns The generated name.
     */
    generateBranchNameFromConfig(name) {
        var _a;
        return __awaiter(this, void 0, void 0, function* () {
            const config = yield this.getConfig();
            let prefix = (_a = config.prefix) !== null && _a !== void 0 ? _a : this.type;
            if (prefix.endsWith('/')) {
                prefix = prefix.slice(0, -1);
            }
            return `${prefix}/${name}`;
        });
    }
    /**
     * Stashes the current local changes.
     *
     * @param project - The git project to be stashed.
     * @returns Returns `true` if changes were stashed. Otherwise `false`.
     */
    stashChanges(project) {
        var _a;
        return __awaiter(this, void 0, void 0, function* () {
            let stashed = false;
            if (((_a = this.projectConfig) === null || _a === void 0 ? void 0 : _a.autoStash) !== false) {
                stashed = yield project.stash();
                if (stashed) {
                    this.logger.info(`Auto stashed current changes`);
                }
            }
            return stashed;
        });
    }
    /**
     * Pops the latest stash into to local repository.
     *
     * @param project - The git project the stash should be popped from.
     */
    popStashedChanges(project) {
        return __awaiter(this, void 0, void 0, function* () {
            yield project.popLatestStash();
            this.logger.info(`Pop auto stashed changes`);
        });
    }
}
exports.GFlowBranch = GFlowBranch;
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiR0Zsb3dCcmFuY2guanMiLCJzb3VyY2VSb290IjoiIiwic291cmNlcyI6WyIuLi8uLi8uLi8uLi9zcmMvZ2Zsb3cvYnJhbmNoZXMvR0Zsb3dCcmFuY2gudHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7O0FBRUEsbUNBQTJDO0FBQzNDLHVFQUFvRTtBQUVwRSwrREFBNEQ7QUFFNUQ7O0dBRUc7QUFDSCxNQUFhLFdBQVc7SUFTdEI7Ozs7O09BS0c7SUFDSCxZQUFZLGFBQTRCLEVBQUUsT0FBdUI7UUFDL0QsSUFBSSxDQUFDLGFBQWEsR0FBRyxhQUFhLENBQUM7UUFDbkMsSUFBSSxDQUFDLGFBQWEsR0FBRyxPQUFPLENBQUM7UUFDN0IsSUFBSSxDQUFDLElBQUksR0FBRyxJQUFJLENBQUMsYUFBYSxDQUFDLElBQUksQ0FBQztRQUNwQyxJQUFJLENBQUMsV0FBVyxHQUFHLElBQUksQ0FBQyxhQUFhLENBQUMsV0FBVyxDQUFDO1FBQ2xELElBQUksQ0FBQyxNQUFNLEdBQUcsa0JBQVMsQ0FBQyxlQUFlLElBQUksQ0FBQyxJQUFJLEdBQUcsQ0FBQyxDQUFDO0lBQ3ZELENBQUM7SUFFRDs7OztPQUlHO0lBQ1UsU0FBUzs7WUFDcEIsT0FBTyxNQUFNLElBQUksQ0FBQyxhQUFhLENBQUMsU0FBUyxFQUFFLENBQUM7UUFDOUMsQ0FBQztLQUFBO0lBRUQ7Ozs7T0FJRztJQUNVLElBQUk7O1lBQ2YsT0FBTyxNQUFNLElBQUksQ0FBQyxhQUFhLENBQUMsSUFBSSxFQUFFLENBQUM7UUFDekMsQ0FBQztLQUFBO0lBRUQ7Ozs7Ozs7T0FPRztJQUNVLEtBQUssQ0FBQyxJQUFhLEVBQUUsSUFBYTs7WUFDN0MsTUFBTSxPQUFPLEdBQUcsSUFBSSx1Q0FBa0IsQ0FBQyxJQUFJLENBQUMsYUFBYSxDQUFDLENBQUM7WUFDM0QsSUFBSSxDQUFDLE1BQU0sQ0FBQyxJQUFJLENBQUMsWUFBWSxJQUFJLENBQUMsSUFBSSxZQUFZLElBQUksZUFBZSxJQUFJLGFBQUosSUFBSSxj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