"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.GitRepository = void 0;
const simple_git_1 = __importDefault(require("simple-git"));
const path_1 = require("path");
const fs_extra_1 = require("fs-extra");
const tools_1 = require("../tools");
const semver_1 = require("semver");
/**
 * A simple API with basic functionality of a git repository.
 */
class GitRepository {
    /**
     * Initializes a new instance of this class.
     *
     * @param config - The project configuration.
     */
    constructor(config) {
        this.config = config;
    }
    /**
     * Gets the folder path of the git repository.
     *
     * @returns The path to the git repository.
     */
    getRepoPath() {
        var _a, _b;
        return (_b = (_a = this.config) === null || _a === void 0 ? void 0 : _a.projectPath) !== null && _b !== void 0 ? _b : process.cwd();
    }
    /**
     * Gets the path of the git repository.
     */
    remove() {
        return __awaiter(this, void 0, void 0, function* () {
            yield fs_extra_1.emptyDir(this.getRepoPath());
            yield fs_extra_1.rmdir(this.getRepoPath());
        });
    }
    /**
     * Ensures the repository exists.
     * If it doesn't exist it will be created.
     */
    ensure() {
        return __awaiter(this, void 0, void 0, function* () {
            yield this.createOrOpenRepo();
        });
    }
    /**
     * Checks out a given branch.
     *
     * @param branchName - Name of the branch to be checked out.
     */
    checkout(branchName) {
        return __awaiter(this, void 0, void 0, function* () {
            const repo = yield this.createOrOpenRepo();
            yield repo.checkout(branchName);
        });
    }
    /**
     * Retrieves the current status of the git repository.
     *
     * @returns The status of the git repository.
     */
    status() {
        return __awaiter(this, void 0, void 0, function* () {
            const repo = yield this.createOrOpenRepo();
            const status = yield repo.status();
            return status;
        });
    }
    /**
     * Adds and commits the given file names to the current branch.
     *
     * @param fileNames - Relative file paths to be added before commit.
     * @param message - Commit message.
     * @param authorName - The name of the author.
     * @param authorMail - Mail address of the author.
     *
     * @returns The hash of the commit.
     */
    commit(fileNames, message, authorName, authorMail) {
        return __awaiter(this, void 0, void 0, function* () {
            const repo = yield this.createOrOpenRepo();
            for (const fileName of fileNames) {
                yield repo.add(fileName);
            }
            let options = undefined;
            if (authorName && authorMail) {
                options = { '--author': `"${authorName} <${authorMail}>"` };
            }
            const hash = yield repo.commit(message, fileNames, options);
            return hash.commit;
        });
    }
    /**
     * Stashes the uncommited changes from the current branch.
     *
     * @returns The message of the stashing.
     */
    stash() {
        return __awaiter(this, void 0, void 0, function* () {
            const repo = yield this.createOrOpenRepo();
            const message = yield repo.stash();
            return message.trim();
        });
    }
    /**
     * Pops stash with a given name.
     */
    popLatestStash() {
        return __awaiter(this, void 0, void 0, function* () {
            const repo = yield this.createOrOpenRepo();
            yield repo.stash(['pop', '-q']);
        });
    }
    /**
     * Ensures there are no uncommited changes (staged and unstaged) in the local workspace.
     */
    ensureNoUnCommitedChanges() {
        return __awaiter(this, void 0, void 0, function* () {
            const repo = yield this.createOrOpenRepo();
            const diff = yield repo.diff(['HEAD']);
            if (diff) {
                throw new Error('There are some uncommited changes.');
            }
        });
    }
    /**
     * Returns the most recent released version tag (semantic version).
     *
     * @returns The version of the latest release.
     */
    getLatestReleasedVersion() {
        return __awaiter(this, void 0, void 0, function* () {
            const repo = yield this.createOrOpenRepo();
            const gitTags = yield repo.tags();
            // Filter all prerelease tags
            const tags = gitTags.all.filter((tag) => {
                const pre = semver_1.prerelease(tag);
                return !pre;
            });
            return tags.pop();
        });
    }
    /**
     * Collects all commit messages since the last release.
     *
     * @returns The logs since the last release.
     */
    getLogsSinceLastRelease() {
        var _a;
        return __awaiter(this, void 0, void 0, function* () {
            const logs = yield this.getDiffLogs();
            const logMessages = logs.map((log) => `${log.message}\n\n${log.body}\n\n${log.refs}`);
            const gitLogs = yield tools_1.Utils.parseConventionalCommits(logMessages, (_a = this.config) === null || _a === void 0 ? void 0 : _a.conventionalCommit);
            gitLogs.forEach((v, i) => (v.hash = logs[i].hash));
            return gitLogs;
        });
    }
    getDiffLogs() {
        return __awaiter(this, void 0, void 0, function* () {
            const repo = yield this.createOrOpenRepo();
            const latestVersion = yield this.getLatestReleasedVersion();
            const logs = yield repo.log({
                from: 'HEAD',
                to: latestVersion,
                symmetric: true,
            });
            return logs.all;
        });
    }
    createOrOpenRepo() {
        return __awaiter(this, void 0, void 0, function* () {
            let repo;
            const path = this.getRepoPath();
            const gitFolder = path_1.join(path, '.git');
            yield fs_extra_1.ensureDir(path);
            if (yield fs_extra_1.pathExists(gitFolder)) {
                repo = simple_git_1.default(path);
            }
            else {
                repo = simple_git_1.default(path);
                yield repo.init();
            }
            return repo;
        });
    }
}
exports.GitRepository = GitRepository;
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiR2l0UmVwb3NpdG9yeS5qcyIsInNvdXJjZVJvb3QiOiIiLCJzb3VyY2VzIjpbIi4uLy4uLy4uL3NyYy9naXQvR2l0UmVwb3NpdG9yeS50cyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7QUFBQSw0REFBdUc7QUFDdkcsK0JBQTRCO0FBQzVCLHVDQUFrRTtBQUdsRSxvQ0FBaUM7QUFDakMsbUNBQW9DO0FBRXBDOztHQUVHO0FBQ0gsTUFBYSxhQUFhO0lBR3hCOzs7O09BSUc7SUFDSCxZQUFZLE1BQXNCO1FBQ2hDLElBQUksQ0FBQyxNQUFNLEdBQUcsTUFBTSxDQUFDO0lBQ3ZCLENBQUM7SUFFRDs7OztPQUlHO0lBQ0ksV0FBVzs7UUFDaEIsT0FBTyxNQUFBLE1BQUEsSUFBSSxDQUFDLE1BQU0sMENBQUUsV0FBVyxtQ0FBSSxPQUFPLENBQUMsR0FBRyxFQUFFLENBQUM7SUFDbkQsQ0FBQztJQUVEOztPQUVHO0lBQ1UsTUFBTTs7WUFDakIsTUFBTSxtQkFBUSxDQUFDLElBQUksQ0FBQyxXQUFXLEVBQUUsQ0FBQyxDQUFDO1lBQ25DLE1BQU0sZ0JBQUssQ0FBQyxJQUFJLENBQUMsV0FBVyxFQUFFLENBQUMsQ0FBQztRQUNsQyxDQUFDO0tBQUE7SUFFRDs7O09BR0c7SUFDVSxNQUFNOztZQUNqQixNQUFNLElBQUksQ0FBQyxnQkFBZ0IsRUFBRSxDQUFDO1FBQ2hDLENBQUM7S0FBQTtJQUVEOzs7O09BSUc7SUFDVSxRQUFRLENBQUMsVUFBa0I7O1lBQ3RDLE1BQU0sSUFBSSxHQUFHLE1BQU0sSUFBSSxDQUFDLGdCQUFnQixFQUFFLENBQUM7WUFDM0MsTUFBTSxJQUFJLENBQUMsUUFBUSxDQUFDLFVBQVUsQ0FBQyxDQUFDO1FBQ2xDLENBQUM7S0FBQTtJQUVEOzs7O09BSUc7SUFDVSxNQUFNOztZQUNqQixNQUFNLElBQUksR0FBRyxNQUFNLElBQUksQ0FBQyxnQkFBZ0IsRUFBRSxDQUFDO1lBQzNDLE1BQU0sTUFBTSxHQUFHLE1BQU0sSUFBSSxD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